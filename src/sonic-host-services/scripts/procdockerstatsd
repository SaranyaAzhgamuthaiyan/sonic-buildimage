#!/usr/bin/env python3
'''
procdockerstatsd
Daemon which monitor docker die and docker start events and generate container exit alarm
'''
import signal
import os
import re
import subprocess
import sys
import time
import docker
import threading
from threading import Thread
from datetime import datetime

from sonic_py_common import daemon_base
import swsssdk

VERSION = '1.0'

SYSLOG_IDENTIFIER = "procdockerstatsd"

REDIS_HOSTIP = "127.0.0.1"

class ProcDockerStats(daemon_base.DaemonBase):

    def __init__(self, log_identifier):
        super(ProcDockerStats, self).__init__(log_identifier)
        self.state_db = swsssdk.SonicV2Connector(host=REDIS_HOSTIP)
        self.state_db.connect("STATE_DB")
        self.history_db = swsssdk.SonicV2Connector(host=REDIS_HOSTIP)
        self.history_db.connect("HISTORY_DB")
        self.client = docker.from_env()

    def update_dockerevents_task(self, event):
        while True:
            for e in self.client.events(filters={"event": event}, decode=True):
                if os.path.exists('/tmp/not_alarm_container_exit'):
                    continue
                epoch_time = time.time_ns()
                container = e['Actor']['Attributes']['name']
                self.log_error("{} {}".format(container, event))
                key = "CURALARM|{}#CONTAINER_EXIT".format(container.upper())
                if event == 'die':
                    data_dict = {}
                    data_dict.update({'time-created': epoch_time})
                    data_dict.update({'id': '{}#CONTAINER_EXIT'.format(container.upper())})
                    data_dict.update({'resource': '{}'.format(container.upper())})
                    data_dict.update({'text': '{} EXITED'.format(container.upper())})
                    data_dict.update({'severity': 'CRITICAL'})
                    data_dict.update({'type-id': 'CONTAINER_EXIT'})
                    data_dict.update({'service-affect': 'false'})
                    for f, v in data_dict.items():
                        self.state_db.set('STATE_DB', key, f, v)

                elif event == 'start':
                    presence = self.state_db.exists('STATE_DB', key)
                    if presence:
                        data_dict = self.state_db.get_all('STATE_DB', key)
                        data_dict.update({'time-cleared': epoch_time})
                        self.state_db.delete('STATE_DB', key)
                        history_key = "HISALARM:{}#CONTAINER_EXIT_{}".format(container.upper(), epoch_time)
                        for f, v in data_dict.items():
                            self.history_db.set('HISTORY_DB', history_key, f, v)
                        self.history_db.expire('HISTORY_DB', history_key, 7 * 24 * 3600)

    def run(self):
        self.log_info("Starting up ...")

        if not os.getuid() == 0:
            self.log_error("Must be root to run this daemon")
            print("Must be root to run this daemon")
            sys.exit(1)

        die_event = Thread(target=self.update_dockerevents_task, args=('die', ))
        start_event = Thread(target=self.update_dockerevents_task, args=('start', ))

        die_event.start()
        start_event.start()

        die_event.join()
        start_event.join()


def main():
    # Instantiate a ProcDockerStats object
    pd = ProcDockerStats(SYSLOG_IDENTIFIER)

    # Log all messages from INFO level and higher
    pd.set_min_log_priority_info()

    pd.run()


if __name__ == '__main__':
    main()
